import funkin.play.PlayState;
import funkin.play.event.SongEvent;
import flixel.util.FlxSave;
import flixel.util.FlxTimer;

import flixel.FlxG;

import funkin.modding.module.Module;
import funkin.modding.module.ModuleHandler;

import funkin.play.character.CharacterDataParser;
import funkin.play.character.CharacterType;
import funkin.play.components.HealthIcon;
import funkin.graphics.FunkinSprite;

import funkin.Paths;
import openfl.utils.Assets;

import funkin.util.assets.DataAssets;

/*
Encore Skins Module
Handles the application of Encore skins (bf-encore, gf-encore) based on the EXEOptions setting:
- "Never": No encore skins, even on encore songs (use default bf/gf)
- "Encore Only": Only apply encore skins to encore songs like Too Slow Encore
- "Always": Apply encore skins to all songs except Pico Mixes, fatality, prey, round-a-bout, and slaybells
*/
class EncoreSkinsModule extends Module {

	//var isEncoreSkin:String = ModuleHandler.getModule("EXEOptions").scriptGet("encoreSkin");

	public function new() {
		super('EncoreSkinsModule');
	}

	// Songs that should be excluded from "Always" mode
	var excludedSongs:Array<String> = [
		'fatality', 'prey', 'round-a-bout', 'slaybells', 'final-escape'
	];

	// Songs that contain Pico (to be excluded from "Always" mode)
	function isPicoMix(songId:String):Bool {
		return PlayState.instance.currentVariation == 'pico';
	}

	// Check if current song is an encore song
	function isEncoreSong():Bool {
		if (PlayState.instance == null || PlayState.instance.currentSong == null) return false;
		
		if (PlayState.instance.currentVariation == 'encore') return true;
		
		return false;
	}

	// Check if encore skins should be applied based on current settings and song
	function shouldApplyEncoreSkins():Bool {
		var exeOptions = ModuleHandler.getModule("EXEOptions");
		if (exeOptions == null) return false;
		
		var mode = exeOptions.scriptGet("encoreSkin");
		var songId = PlayState.instance.currentSong.id.toLowerCase();
		
		switch (mode) {
			case "Never":
				return false;
			case "Encore Only":
				return isEncoreSong();
			case "Always":
				// Apply to all songs except excluded ones and Pico mixes
				if (isPicoMix(songId) || excludedSongs.contains(songId)) {
					return false;
				}
				return true;
			default:
				return false;
		}
	}

	// Check if encore skins should be removed (for "Never" mode on encore songs)
	function shouldRemoveEncoreSkins():Bool {
		var exeOptions = ModuleHandler.getModule("EXEOptions");
		if (exeOptions == null) return false;
		var mode = exeOptions.scriptGet("encoreSkin");
		return (mode == "Never" && isEncoreSong()); // Never mode on encore songs
	}

	public function onSongRetry(event):Void {
		super.onSongRetry(event);
		if (PlayState.instance == null || PlayState.instance.currentStage == null) return;
		if (PlayState.instance.isMinimalMode) return;

		applySkinLogic();
	}

	override function onSongLoaded(event) {
		super.onSongLoaded(event);
		if (PlayState.instance == null || PlayState.instance.currentStage == null) return;
		if (PlayState.instance.isMinimalMode) return;
		
		applySkinLogic();
	}

	function applySkinLogic() {
		var shouldApply = shouldApplyEncoreSkins();
		var shouldRemove = shouldRemoveEncoreSkins();

		// Handle Boyfriend
		var currentBF = PlayState.instance.currentChart.characters.player;
		if (shouldApply) {
			// Apply encore skin if not already applied
			if (currentBF == 'bf') {
				changeCharacter('bf-encore', 'bf');
			} else if (currentBF == 'bf-endless') {
				changeCharacter('bf-encore-endless', 'bf');
			}
		} else if (shouldRemove) {
			// Remove encore skin if currently applied
			if (currentBF == 'bf-encore') {
				changeCharacter('bf', 'bf');
			} else if (currentBF == 'bf-encore-endless') {
				changeCharacter('bf-endless', 'bf');
			}
		}

		// Handle Girlfriend
		if (PlayState.instance.currentStage.getGirlfriend() != null) {
			var currentGF = PlayState.instance.currentChart.characters.girlfriend;
			if (shouldApply) {
				// Apply encore skin if not already applied
				if (currentGF == 'gf') {
					changeCharacter('gf-encore', 'gf');
				}
			} else if (shouldRemove) {
				// Remove encore skin if currently applied
				if (currentGF == 'gf-encore') {
					changeCharacter('gf', 'gf');
				}
			}
		}
	}

	public override function onSongEvent(scriptEvent:SongEventScriptEvent) {
		var script = scriptEvent;
		if (scriptEvent.eventData.eventKind == "ChangeCharacterCL" || scriptEvent.eventData.eventKind == "ChangeCharacter") {
			var eventProps = scriptEvent.eventData.value;
			new FlxTimer().start(0.0001, _ -> {
				var newChar = eventProps.newchar.toLowerCase();
				var targetChar = eventProps.character.toLowerCase();
				
				var shouldApply = shouldApplyEncoreSkins();
				var shouldRemove = shouldRemoveEncoreSkins();

				// Handle character change events
				if (shouldApply) {
					if (newChar == 'bf' && (targetChar == 'bf' || targetChar == 'player')) {
						script.cancel();
						changeCharacter('bf-encore', targetChar);
					} else if (newChar == 'bf-endless' && (targetChar == 'bf' || targetChar == 'player')) {
						script.cancel();
						changeCharacter('bf-encore-endless', targetChar);
					} else if (newChar == 'gf' && (targetChar == 'gf' || targetChar == 'girlfriend')) {
						script.cancel();
						changeCharacter('gf-encore', targetChar);
					} else {
						super.onSongEvent(script);
					}
				} else if (shouldRemove) {
					if (newChar == 'bf-encore' && (targetChar == 'bf' || targetChar == 'player')) {
						script.cancel();
						changeCharacter('bf', targetChar);
					} else if (newChar == 'bf-encore-endless' && (targetChar == 'bf' || targetChar == 'player')) {
						script.cancel();
						changeCharacter('bf-endless', targetChar);
					} else if (newChar == 'gf-encore' && (targetChar == 'gf' || targetChar == 'girlfriend')) {
						script.cancel();
						changeCharacter('gf', targetChar);
					} else {
						super.onSongEvent(script);
					}
				} else {
					super.onSongEvent(script);
				}
			});
		}
	}

	function changeCharacter(newName:String, character:String) {
		var charData = CharacterDataParser.parseCharacterData(newName);
		CharacterDataParser.characterCache.h[CharacterDataParser.characterCache.h.length+1] = charData;

		switch (character) {
			case 'bf', 'player':
				var bfZIndex = PlayState.instance.currentStage.getBoyfriend().zIndex;
				if (bfZIndex == null) bfZIndex = 0;
		
				PlayState.instance.currentStage.getBoyfriend().destroy();
		
				var boyfriend = CharacterDataParser.fetchCharacter(newName);
				if (boyfriend != null) {
					boyfriend.set_characterType(CharacterType.BF);
					boyfriend.initHealthIcon(false);
					PlayState.instance.currentStage.addCharacter(boyfriend, CharacterType.BF);
					PlayState.instance.currentStage.getBoyfriend().zIndex = bfZIndex;
				}
			case 'gf', 'girlfriend':
				var gfZIndex = PlayState.instance.currentStage.getGirlfriend().zIndex;
				if (gfZIndex == null) gfZIndex = 0;
		
				PlayState.instance.currentStage.getGirlfriend().destroy();
		
				var girlfriend = CharacterDataParser.fetchCharacter(newName);
				if (girlfriend != null) {
					girlfriend.set_characterType(CharacterType.GF);
					PlayState.instance.currentStage.addCharacter(girlfriend, CharacterType.GF);
					PlayState.instance.currentStage.getGirlfriend().zIndex = gfZIndex;
				}
			case 'dad', 'opponent':
				var oppZIndex = PlayState.instance.currentStage.getDad().zIndex;
				if (oppZIndex == null) oppZIndex = 0;
		
				PlayState.instance.currentStage.getDad().destroy();
		
				var dad = CharacterDataParser.fetchCharacter(newName);
				if (dad != null) {
					dad.set_characterType(CharacterType.DAD);
					dad.initHealthIcon(true);
					PlayState.instance.currentStage.addCharacter(dad, CharacterType.DAD);
					PlayState.instance.currentStage.getDad().zIndex = oppZIndex;
				}
		}
		PlayState.instance.currentStage.refresh();
	}
}