import flixel.FlxG;
import flixel.ui.FlxBar;
import flixel.FlxSprite;
import funkin.play.PlayState;
import funkin.modding.module.Module;
import funkin.modding.module.ModuleHandler;
import funkin.util.tools.StringTools;
import funkin.util.Constants;
import Math;
import Std;
import haxe.ds.StringMap;
import haxe.ds.IntMap;

class ColoredHealthbar extends Module {
    // I couldn't get it to disable the clean way so I just added the check to literally every function

    /* Some code by nubz4lif on GameBanana
      * https://gamebanana.com/mods/511342
    */

    var iconRes = 150;
    
    static var defaultHBGreen = Constants.COLOR_HEALTH_BAR_GREEN;
    static var defaultHBRed = Constants.COLOR_HEALTH_BAR_RED;
    
    var inPlay = false;
    
    static var bfColor;
    static var dadColor;
    
    static var bfLastChar:String = '';
    static var dadLastChar:String = '';
    
    static var iconColorCache:StringMap;
    static var lastDoColoredIcons:Bool = true;
    
    function new() {
        iconColorCache = new StringMap();
        super("ColoredHealthbar", 0);
    }
    
    function checkSettingChange() {
        var currentDoColoredIcons = false;
        try {
            var exeOptions = ModuleHandler.getModule("EXEOptions");
            if (exeOptions != null) {
                currentDoColoredIcons = exeOptions.scriptGet("hpcolors");
            }
        } catch (e:Dynamic) {
            currentDoColoredIcons = false;
        }
        
        // If the setting changed from enabled to disabled, clear cache and reset colors
        if (lastDoColoredIcons && !currentDoColoredIcons) {
            clearCacheAndResetColors();
        }
        
        lastDoColoredIcons = currentDoColoredIcons;
        return currentDoColoredIcons;
    }
    
    function clearCacheAndResetColors() {
        // Clear the icon color cache
        iconColorCache = new StringMap();
        
        // Reset colors to defaults
        bfColor = null;
        dadColor = null;
        bfLastChar = '';
        dadLastChar = '';
        
        // Reset constants to default values
        Constants.COLOR_HEALTH_BAR_GREEN = defaultHBGreen;
        Constants.COLOR_HEALTH_BAR_RED = defaultHBRed;
        
        // Reset healthbar colors if in play
        if (inPlay && PlayState.instance != null && PlayState.instance.healthBar != null) {
            PlayState.instance.healthBar.createFilledBar(defaultHBRed, defaultHBGreen);
            PlayState.instance.healthBar.updateBar();

            // Reset healthbar background color if it exists
            if (PlayState.instance.healthBarBG != null) {
                PlayState.instance.healthBarBG.color = 0xFFFFFFFF; // Reset to white/default
            }
        }
    }
    
    function getIconColor(icon:FlxSprite, ?resMult:Float = 1.0, ?dontUseCache = false) {
        doColoredIcons = checkSettingChange();
        if (!doColoredIcons) return;
        
        if (!dontUseCache && iconColorCache.get(icon.characterId) != null) {
            return iconColorCache.get(icon.characterId);
        } else {
            var color = dominantColor(icon, resMult);
            iconColorCache.set(icon.characterId, color);
            return color;
        }
    }

    function dominantColor(sprite:FlxSprite, ?resMult:Float = 1.0) {
        doColoredIcons = checkSettingChange();
        if (!doColoredIcons) return;
        
        if (sprite == null || !inPlay) return;
        
        var mult:Float = Math.min(1, (iconRes / sprite.frameWidth) * resMult);
        
        var countByColor:Array<Int> = [];
        var colorById:Array<Int> = [];
        
        for (col in 0...(sprite.frameWidth) * mult) {
            for (row in 0...(sprite.frameHeight) * mult) {
                var colorOfThisPixel:Int = sprite.pixels.getPixel32(col / mult, row / mult);
                
                if (colorOfThisPixel != 0) {
                    var colorId = colorById.indexOf(colorOfThisPixel);
                    if (colorId != -1) {
                        countByColor[colorId] = countByColor[colorId] + 1;
                    } else {
                        var id = colorById.length;
                        colorById[id] = colorOfThisPixel;
                        countByColor[id] = 1;
                    }
                }
            }
        }

        var maxCount:Int = 0;
        var maxKey:Int = 0;
        
        for (color in colorById) {
            var id = colorById.indexOf(color);
            var count = countByColor[id] != null ? countByColor[id] : 0;
            
            if (id != -1 && count > maxCount && color != 0xFF000000 && color != 0x00FFFFFF) {
                var alpha = (color >> 24) & 0xff;
                if (alpha >= 255) {
                    maxCount = count;
                    maxKey = color;
                }
            }
        }
        
        countByColor = [];
        colorById = [];
        
        return maxKey;
    }
    
    function updateHealthBarColors(?resMult:Float = 1.0, ?forced:Bool = false) {
        doColoredIcons = checkSettingChange();
        if (!doColoredIcons) return;

        if (!inPlay) return;

        // Add null checks for PlayState.instance and icons
        if (PlayState.instance == null || PlayState.instance.iconP1 == null || PlayState.instance.iconP2 == null) return;

        var shouldFill = false;

        if (PlayState.instance.iconP1.characterId != bfLastChar || forced) {
            bfColor = getIconColor(PlayState.instance.iconP1, resMult, forced);
            bfLastChar = PlayState.instance.iconP1.characterId;
            shouldFill = true;
        }

        if (PlayState.instance.iconP2.characterId != dadLastChar || forced) {
            dadColor = getIconColor(PlayState.instance.iconP2, resMult, forced);
            dadLastChar = PlayState.instance.iconP2.characterId;
            shouldFill = true;
        }

        if (shouldFill) fillHealthBar();
    }
    
    function fillHealthBar() {
        doColoredIcons = checkSettingChange();
        if (!doColoredIcons) return;

        bfColor = (bfColor != null ? bfColor : defaultHBGreen);
        dadColor = (dadColor != null ? dadColor : defaultHBRed);

        Constants.COLOR_HEALTH_BAR_GREEN = bfColor;
        Constants.COLOR_HEALTH_BAR_RED = dadColor;

        if (!inPlay || PlayState.instance == null || PlayState.instance.healthBar == null) return;

        PlayState.instance.healthBar.createFilledBar(dadColor, bfColor);
        PlayState.instance.healthBar.updateBar();

        // Color the healthbar background asset if EXE HUD is enabled
        colorHealthBarAsset();
    }
    
    function colorHealthBarAsset() {
        doColoredIcons = checkSettingChange();
        if (!doColoredIcons) return;

        var exeHudEnabled = false;
        try {
            var exeOptions = ModuleHandler.getModule("EXEOptions");
            if (exeOptions != null) {
                exeHudEnabled = exeOptions.scriptGet("exehud");
            }
        } catch (e:Dynamic) {
            exeHudEnabled = false;
        }

        if (!exeHudEnabled || !inPlay || PlayState.instance == null || PlayState.instance.healthBarBG == null) return;

        // Only color the hpR-light asset, not fatalHealth
        var currentStage = PlayState.instance.currentStage?.id ?? "";
        if (currentStage == "fatalZone") return; // Don't color fatalHealth asset

        // Apply opponent's dominant color to the healthbar background
        if (dadColor != null) {
            PlayState.instance.healthBarBG.color = dadColor;
        }
    }
    
    function onPlayStateEnter() {
        doColoredIcons = checkSettingChange();
        if (!doColoredIcons) return;
        
        // Forcing this does add a tiny bit of loading time, but ensures that colors won't be wrong
        updateHealthBarColors(1, true);
    }
    
    override function onStateChangeBegin(ev:ScriptEvent) {
        doColoredIcons = checkSettingChange();
        if (!doColoredIcons) return;
        
        super.onStateChangeBegin(ev);
        inPlay = false;
    }
    
    override function onStateChangeEnd(ev:ScriptEvent) {
        doColoredIcons = checkSettingChange();
        if (!doColoredIcons) return;
        
        super.onStateChangeEnd(ev);
        
        inPlay = Std.isOfType(FlxG.state, PlayState);
        
        if (PlayState.instance != null && inPlay) {
            onPlayStateEnter();
            return;
        }
    }
    
    override function onBeatHit(ev:ScriptEvent) {
        doColoredIcons = checkSettingChange();
        if (!doColoredIcons) return;
        
        updateHealthBarColors(0.25);
        super(ev);
    }
    
    override function onSongEvent(ev:ScriptEvent) {
        doColoredIcons = checkSettingChange();
        if (!doColoredIcons) return;
        
        updateHealthBarColors(0.5);
        super(ev);
    }
    
    override function onPause(ev:ScriptEvent) {
        doColoredIcons = checkSettingChange();
        if (!doColoredIcons) return;
        
        super(ev);
        updateHealthBarColors(1);
    }
}